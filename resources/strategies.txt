Search depth-first.
Search breadth-first.
Could you explain it to your grandparents?
What is your hypothesis? Write it in words.
What goes in? What comes out?
What are you optimizing? Why?
Try a different heuristic.
Solve the metaproblem.
Closer to the hardware.
Further from the hardware.
Take it apart and put it back together.
Write an abstraction.
Break an abstraction barrier.
What are the trade-offs? Make a trade.
Write more tests.
Write the comments first.
Make it stateless.
Kludge now, fix later.
Does it really have to be so precise?
Change something unexpected and see what happens.
Ask for help.
Solve it recursively.
Is it elegant?
Would you rather mold clay or chisel marble?
What does it want to look like?
What can't you ship?
Where are the interactions?
Which parts are moving?
What are you so sure of?
Code on a whiteboard.
Draw a picture.
Feed it something weird.
Try to break it.
Is it a graph? It's probably a graph.
Read it backwards.
Which parts are tightly coupled?
Climb a hill.
Climb a thousand hills.
Be greedier.
Exaggerated hubris.
What are you modeling?
Let one hundred functions bloom. (One data structure)
Be very quiet. The code is whispering something in your ear. 
What don't you know? What can't you know?
What can't you observe?
What do you see? Are you sure?
Build bottom-up.
Start with the answer.
Write exactly what you're trying to do in words.
Read someone else's code.
How much does this cost?
Build a prototype. Break a prototype.
Translate it to another language.
Be lazier.
Make it more beautiful.
Make it more simple.
Flatten it.
What rules are you breaking?
What rules can you break?
Which parts are implicit?
Do you hear that? Make it louder.
Print everything everywhere.
Go to bed. It's 4am. 
Write everything you know about the problem. Go take a walk.
Pretend you fixed it and carry on.
A little better each time.
What is undefined?
Narrow the problem space.
Brute force has its uses.
Read a book.
Who (what) is lying to you?
Construct something isomorphic.
Examine degenerate cases.
Slaves of some defunct algorithm.
Eliminate the impossible. What's left?
Is this the right tool?
What can change? What has to stay the same?
Describe the design pattern.
Which parts are in conflict? You can't satisfy everyone.
You will know you are using the other side of your brain when you feel a dull tingling sensation behind your left ear.
What's your intuition? Turn up the contrast.
What happens when you approach the limits?
Write a TODO list.
Start with the README.
This would make a good blog post.
New branch, clean slate.
Use a different tool.
Is there a better analogy?
Ask someone older.
Everything begins with a base case.
What's your control?
Evolve the solution.
The tool you need is simpler than you think.
Draw the decision tree.
Sit under a tree and read the documentation.
Visualize it. What do you see?
Are you solving the right problem?
Apply a transformation.
Treat time as a series of states.
Facts are things, not places.
What will break it?
Which parts are you proud of?
Which parts embarrass you?
You are a scientist.
Slow it down.
Obliterate all luck.
Focus. Blur. Focus.
Remove the tiniest pieces until it collapses.
Lean into sharp points.
You are an artist.
Examine the most obvious thing in exasperating detail.
You are always a novice.
Use the most boring tool you can think of.
Write the instructions without words.
How does it flow?
What is the narrowest point?
What if you're wrong?
A good heuristic is optimistic.
Move your body to a new and different place.
Abstract something concrete.
Write out an example.
Satisfice, then optimize.
Fast and frugal.
What are your priors?
Invert it.
What happens in the worst case?
Exploit randomness.
Introduce a mutation.
Apply a filter. What's the test condition?
What are the simplest parts?
This is just a problem set.
If this were an exam question, what would it be?
Do the math.
What worked last time? Ignore it.
Your idea is not as special as you think.
Marginal change/Marginal changes.
One whole, many parts.
Iterative improvement.
Write it as math.
Be more precise.
Smaller steps.
The model is not the system.
Try your silliest idea.
Focus on the boring parts.
Why?
What if there were no constraints?
Why is it divided like that?
What would a child ask?
How does nature do it?
Many solutions, not just one.
Refine. Combine. Refine.
Think in another language.
What are the side effects?
Use a tool that intimidates you.
Teach it to yourself.
What bothers you?
Show the world your worst rough draft.
Omit needless words.
Reduce.
Map.
Filter.
Sort into groups.
How many dimensions?
Describe everything.
Relax a requirement and tighten it later.
Prophesy the future.
One idea at a time.
All conjecture is a creative act.
Problems are soluble. Problems are inevitable. 
Check your work.
Systematic oversimplification.
Criticize it.
What is the unknown? What are the data?
Practicality beats purity.
Make it more readable.
Is it testable? Are you sure?
Rejoice in corner cases.
Bad memes can spread fast.
Switch roles: you are the computer.
Use different symbols.
Use a dirty trick.
Not changing, flowing.
Complexity is not randomness.
Good taste matters.
Is your solution the problem?
Broader input, better output.
Subject yourself to withering criticism.
Go away from the computer.
Beware local maxima.
Celebrate local maxima.
Strategy precedes tactics.
Balance is an underrated virtue.
Practice radical openness.
Math is beautiful. Words are readable. (Words are beautiful, math is readable) 
More like prose, less like math.
Line by line, bird by bird. 
Be ordinary in your tools to be violent and original in your works. 
Software is a model of your intentions.
A program is not a blend of instructions. (A theme in music is not a blend of notes.)
Is it articulate?
Sleep on it.
Change the notation.
Patience.
As simple as possible, but no simpler.
Reduce the dimensions.
Examine repeatedly, in different ways.
Decompose. Recombine.
Bolt something on.
Planning is overrated.
The limits of my language mean the limits of my world.
Say no to something.
Defaults are powerful. Check your settings.
Make something that frightens you.
Solve the hardest problem first.
Bigger concepts.
You are a human.
Plans should be proportional to risk.
Use your secret weapon.
Both clean and dirty.
Are the bottlenecks where you think they are?
The most important part of design is redesign.
When payoffs are poor, restructure the game.
Would you want to use it?
Successive approximation.
Different kinds of symmetry: Repetition, recursion.
Some complex solutions cannot be designed.
Designed, but unplanned.
Throwing away bad code is an act of courage.
Carefully engineer your mistakes.
Weirdness is an organic phenomenon.
Truth sometimes fails the test suite.
Accurate measurements, not easy ones.
New versus good.
Too much choice is paralyzing.
Two trees: designed, evolved.
Diminishing marginal returns.
You are writing an essay.
Layers.
Write down the program you'd like to write. 
Two ways to break the rules: imaginative and ugly.
Good writing is rewriting.
The hardest problem is hiding from you.
Most important first.
Reuse standard tools.
Treat abstraction like a natural phenomenon. Where are the frontiers?
Simple is not easy.
Feedback fights uncertainty.
Don't teach to the test(s).
Three meanings of naive: crude, unenlightened, bold.
What are you curious about?
Why do you have two of those?
Clear your cache.
Your model is always wrong.
Soluble problems dissolve. (All problems are soluble)
Someone else has solved this problem.
How carefully did you read that?
How many states?
